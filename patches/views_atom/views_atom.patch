? views_atom.patch
Index: views_atom.module
===================================================================
RCS file: /cvs/drupal-contrib/contributions/modules/views_atom/views_atom.module,v
retrieving revision 1.1.2.1
diff -u -p -r1.1.2.1 views_atom.module
--- views_atom.module	31 Dec 2010 22:07:37 -0000	1.1.2.1
+++ views_atom.module	3 Feb 2011 11:11:35 -0000
@@ -141,7 +141,11 @@ function views_atom_sanitize($string) {
 /**
  * Implementation of hook_views_atom_render().
  */
-function content_views_atom_render($node, $entity_xml) {
+function content_views_atom_render($node, $entity_xml, $display = NULL) {
+  $view = NULL;
+  if ($display != NULL) {
+    $view = $display->view;
+  }
   // If there are any Fields associated with this entity, those each get
   // added via a <field> element.  Each <field> element is assumed to be
   // multi-value, just as Fields in Drupal are.
@@ -149,25 +153,51 @@ function content_views_atom_render($node
   // This is totally the wrong way to do it, but CCK's API is too convoluted
   // for me to figure out something else right now.
   $result = db_query("SELECT field_name, type FROM {content_node_field}");
+  
+   // If $view != NULL, only show fields that are in the view
+  if ($view != NULL) {
+		$full_keys = array();
+		$keys = array_keys($view->field);
+		foreach ($keys as &$key) {
+			// Find position of the last _
+			$pos = strrpos($key, '_');
+			$view_id = $key;
+			$key = substr($key, 0, $pos);
+			$full_keys[$key] = $view_id;
+		}
+	}
 
   while ($record = db_fetch_object($result)) {
     if (!empty($node->{$record->field_name})) {
-      $field = array_filter($node->{$record->field_name});
-      $field_xml = $entity_xml->addChild('field');
-      $field_xml->addAttribute('type', $record->type);
-      $field_xml->addAttribute('name', $record->field_name);
-      foreach ($field as $instance) {
-        $field_instance_xml = $field_xml->addChild('field-instance');
-        foreach ($instance as $column => $value) {
-          $serialize = FALSE;
-          if (is_array($value)) {
-            $value = serialize($value);
-            $serialize = TRUE;
-          }
-          $element_xml = $field_instance_xml->addChild('column', views_atom_sanitize($value));
-          $element_xml->addAttribute('name', $column);
-          if (!empty($serialize)) {
-            $element_xml->addAttribute('serialize', $serialize);
+      $add_field = TRUE;
+      $label = $record->field_name;
+      if ($view != NULL) {
+        $view_id = $full_keys[$record->field_name];
+        if ($view->field[$view_id]->options['label']) { // If there is a label
+          $label = $view->field[$view_id]->options['label'];
+        }
+        if (!in_array($record->field_name, $keys) || $view->field[$view_id]->options['exclude']) {
+          $add_field = FALSE;
+        }
+      }
+      if ($add_field) {
+        $field = array_filter($node->{$record->field_name});
+        $field_xml = $entity_xml->addChild('field');
+        $field_xml->addAttribute('type', $record->type);
+        $field_xml->addAttribute('name', $record->field_name);
+        foreach ($field as $instance) {
+          $field_instance_xml = $field_xml->addChild('field-instance');
+          foreach ($instance as $column => $value) {
+            $serialize = FALSE;
+            if (is_array($value)) {
+              $value = serialize($value);
+              $serialize = TRUE;
+            }
+            $element_xml = $field_instance_xml->addChild('column', views_atom_sanitize($value));
+            $element_xml->addAttribute('name', $column);
+            if (!empty($serialize)) {
+              $element_xml->addAttribute('serialize', $serialize);
+            }
           }
         }
       }
@@ -192,6 +222,19 @@ function filefield_views_atom_render_fie
   }
 }
 
+function nodereference_views_atom_render_field(SimpleXMLElement $field_xml, $field, $field_type) {
+  // Give the full guid of the node
+  if ($field_type == 'nodereference') {
+    $instances = $field_xml->{'field-instance'};
+    
+    foreach ($field as $i => $instance) {
+      $nid = $instance['nid'];
+      $new_column = $instances[$i]->addChild('column', views_atom_guid('node', $nid));
+      $new_column->addAttribute('name', 'guid');
+    }
+  }
+}
+
 /**
  * Implementation of hook_views_atom_render().
  */
Index: views_atom.theme.inc
===================================================================
RCS file: /cvs/drupal-contrib/contributions/modules/views_atom/views_atom.theme.inc,v
retrieving revision 1.1.2.4
diff -u -p -r1.1.2.4 views_atom.theme.inc
--- views_atom.theme.inc	31 Dec 2010 22:07:37 -0000	1.1.2.4
+++ views_atom.theme.inc	3 Feb 2011 11:11:35 -0000
@@ -74,6 +74,22 @@ function template_preprocess_views_view_
   $vars['updated'] = $now;
 
   $vars['items'] = array();
+  
+  // @todo Find a way to fix this really dirty hack !!!!
+  if (empty($vars['rows'])) {
+    $i = 0;
+    while (arg($i) != '') {
+      if (is_numeric(arg($i))) {
+        $nid = arg($i);
+        $node = new stdClass();
+        $node->nid = $nid;
+        $vars['rows'][0] = $node;
+        break;
+      }
+      $i++;
+    }
+  }
+  
   $guid_options = isset($vars['view']->style_options['guid']) ? $vars['view']->style_options['guid'] : array();
   // Now process the rows into deletion information.
   foreach ($vars['rows'] as $i => $row) {
Index: views_atom.views.inc
===================================================================
RCS file: /cvs/drupal-contrib/contributions/modules/views_atom/views_atom.views.inc,v
retrieving revision 1.1.2.1
diff -u -p -r1.1.2.1 views_atom.views.inc
--- views_atom.views.inc	31 Dec 2010 22:07:37 -0000	1.1.2.1
+++ views_atom.views.inc	3 Feb 2011 11:11:35 -0000
@@ -66,6 +66,19 @@ function views_atom_views_plugins() {
     'type' => 'feed',
     'parent' => 'rdf',
   );
+  
+  $info['row']['rdf_node_custom'] = array(
+    'title' => t('RDF (Nodes) Custom'),
+    'help' => t('Displays the fields with their defined labels'),
+    'handler' => 'views_plugin_row_rdf_node_custom',
+    'theme' => 'views_view_rdf',
+    'theme file' => 'views_atom.theme.inc',
+    'theme path' => drupal_get_path('module', 'views_atom'),
+    'uses fields' => TRUE,
+    'uses options' => TRUE,
+    'type' => 'feed',
+    'parent' => 'rdf'
+  );
 
   return $info;
 }
Index: views_plugin_row_rdf_node_custom.inc
===================================================================
RCS file: views_plugin_row_rdf_node_custom.inc
diff -N views_plugin_row_rdf_node_custom.inc
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ views_plugin_row_rdf_node_custom.inc	3 Feb 2011 11:12:02 -0000
@@ -0,0 +1,116 @@
+<?php
+// $Id: views_plugin_row_rdf_node.inc,v 1.1 2010/09/21 21:36:52 crell Exp $
+
+/**
+ * @file
+ * Contains the RDF row style plugin.
+ */
+
+/**
+ * Plugin which performs a node_view on the resulting object
+ * and formats it as an RSS item.
+ */
+class views_plugin_row_rdf_node_custom extends views_plugin_row_rdf {
+  // Basic properties that let the row style follow relationships.
+  var $base_table = 'node';
+  var $base_field = 'nid';
+  
+  function option_definition() {
+    $options = parent::option_definition();
+    $options['taxonomy_mapping'] = array('default' => '');
+
+    return $options;
+  }
+
+  /**
+   * Provide a form for setting options.
+   */
+  function options_form(&$form, &$form_state) {
+    
+    $form['taxonomy_mapping'] = array(
+      '#type' => 'textarea',
+      '#title' => t('Taxonomy mapping'),
+      '#description' => t('Enter the mapping of the vocabularies, under the form key|label, one per line'),
+      '#default_value' => $this->options['taxonomy_mapping']
+    );
+  }
+
+  function render($row) {
+    // For the most part, this code is taken from node_feed() in node.module
+    global $base_url;
+
+    $nid = $row->{$this->field_alias};
+    if (!is_numeric($nid)) {
+      return;
+    }
+
+    $node = node_load($nid);
+
+    // Allow other modules to modify the node before we start serializing it.
+    module_invoke_all('views_atom_prerender', $node);
+    module_invoke_all('views_atom_prerender_node', $node);
+
+    // We need to start with a DOMDocument because SimpleXML's namespace handling
+    // is abysmal.  Fortunately we can swap back and forth as needed.
+    // @todo: Add more common namespaces here if needed.
+    $dom = new DOMDocument('1.0');
+    $rdf_xml = $dom->createElementNS('http://www.w3.org/1999/02/22-rdf-syntax-ns', 'rdf:RDF');
+    $dom->appendChild($rdf_xml);
+
+    // Get a SimpleXML version of the object for serious manipulation, since
+    // its API is much easier to work with.
+    $xml = simplexml_import_dom($dom);
+
+    // Create the base entity element that wraps all Drupal data objects.
+    $entity_xml = $xml->addChild('entity', NULL, 'http://drupal.org/');
+
+    // Node type is more generically "bundle", at least in Drupal 7 speak.
+    $entity_xml->addAttribute('type', 'node');
+    $entity_xml->addAttribute('bundle', check_plain($node->type));
+
+    $entity_xml->addChild('title', views_atom_sanitize($node->title));
+
+    // Properties are primitive data associated with the entity.  These are
+    // standard by entity type.  Those all get wrapped in a <properties> element.
+    $properties_xml = $entity_xml->addChild('properties');
+
+
+    $keys = array_keys($this->view->field);
+    // Since we don't have a complete map of available properties, we'll just
+    // treat any primitive values on the node object as properties.  That will
+    // get more than we need, but it works well enough.
+    foreach ($node as $property => $value) {
+      if (is_scalar($value) && !empty($value)) {
+        // We want to map the date fields to Atom/RDF format properly.  The others
+        // we'll just send along as is.
+        if (in_array($property, array('created', 'changed'))) {
+          $properties_xml->addChild($property, date('c', $value));
+        }
+        else {
+          // Make sure the property is part of the view fields and not excluded from display
+          if (in_array($property, $keys) && !$this->view->field[$property]->options['exclude']) {
+            $properties_xml->addChild($property, views_atom_sanitize($value));
+          }
+        }
+      }
+    }
+
+    // Allow other modules the opportunity to get in on the XML conversion action.
+    module_invoke_all('views_atom_render', $node, $entity_xml, $this);
+    module_invoke_all('views_atom_render_node', $entity_xml);
+
+    drupal_alter('views_atom_render_rdf', $entity_xml, $node);
+
+    // Force pretty formatting to make debugging easier.  It doesn't actually
+    // affect parsing.  Note that because all objects in PHP are references
+    // this $dom variable still has all of the changes made above using SimpleXML.
+    // That's neat.
+    $dom->formatOutput = TRUE;
+
+    // This is stupid and bad, but I don't know of another way to supress the
+    // <?xml crap.
+    // @todo Find a better way to not get the XML declaration in the output.
+    $output = $dom->saveXML();
+    return str_replace('<?xml version="1.0"?>' . "\n", '', $output);
+  }
+}
